#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Mon May  7 11:05:46 2018

@author: duilio
"""

import numpy as np
import pydicom
import dicom
import os
 
def load_dicoms(directory):
 
    filelist = [ name for name in os.listdir(directory) if name.find(".dcm") > 0 ]
    filelist.sort()
    num_images = len(filelist)  
    counter = 0
 
    filenames = []
    data = np.empty((num_images, 512, 512, 1))   # Each DaTsan image contains 320 x 320 pixels  
 
    for filename in filelist:
        filenames.append(filename)
        image = pydicom.dcmread(os.path.join(directory, filename))  # filename is two directories down from where this is running
        rows = image.Rows
        assert rows == 512
        cols = image.Columns
        assert cols == 512
 
        for x in range(0, 512):
            for y in range(0, 512):
              data[counter][x][y] = image.pixel_array[x][y]
        counter = counter + 1
   
    save_cache(directory, data)
 
    return data

def load_cache_dicoms(directory):
    return np.load(os.path.join(directory, '.cache.npy'))
   
def save_cache(directory, data):
   
    np.save(os.path.join(directory, '.cache'), data)
 
def cache_is_present(directory):
   
    return ".cache.npy" in os.listdir(directory)

def extract_images(directory):
   
    print('Extracting', directory)
 
    if cache_is_present(directory):
        print('Cache found')
        return load_cache_dicoms(directory)
    else:
        print('No cache')
        return load_dicoms(directory)
 
    
def extract_dataset(folder, bounds = .2):
 
    dirs = os.listdir(folder)
    dirs = [ label for label in dirs if label[0] != '.' ]
    dirs.sort()
 
    # print labels
    print(dirs)

 
    data_train = []
    data_test = []
    label_train = []
    label_test = []
 
    index = 0
    for label in dirs:
 
        subdir = os.path.join(folder, label)
        subdirs = [ label for label in os.listdir(subdir) if label[0] != '.' ]
 
        subdir_index = 0
       
        for container in subdirs:
 
            data = extract_images(os.path.join(subdir, container))
 
            if subdir_index > bounds * len(subdirs):
                new_train = []
 
                for img in data:
                    new_train.append(img)
 
                data_train.append(new_train)
                label_train.append(index)
            else:
                new_test = []
 
                for img in data:
                    new_test.append(img)
 
                data_test.append(new_test)
                label_test.append(index)
 
            subdir_index += 1
 
        index += 1
 
    data_train = np.array(data_train)
    data_test = np.array(data_test)
    label_train = np.array(label_train)
    label_test = np.array(label_test)
 
    return (data_train, label_train), ( data_test, label_test )
 
    
# dicom_cnn.py
#from __future__ import print_function
import numpy as np
np.random.seed(1337)  # for reproducibility
 
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Dense, Dropout, Activation, Flatten
from keras.layers import Convolution2D, Convolution3D, MaxPooling2D, MaxPooling3D
from keras.utils import np_utils
from keras import backend as K

import extract_dicom as ext
 
batch_size = 2
nb_classes = 2
nb_epoch = 3
 
folder="/home/duilio/Escritorio/EGGS_DIANA"
# number of convolutional filters to use
nb_filters = 32
# size of pooling area for max pooling
pool_size = (2, 2)
# convolution kernel size
kernel_size = (3, 3)
#(X_train, y_train), (X_test, y_test) = extract_dataset(folder)
# the data, shuffled and split between train and test sets
(X_train, y_train), (X_test, y_test) = ext.extract_dataset(folder)
#print('X_train shape:', X_train.shape)
#print('X_test shape:', X_test.shape)
#print(X_train.shape[0], 'train samples')
#print(X_test.shape[0], 'test samples')
 
# Convert class vectors to binary class matrices.
#Y_train = np_utils.to_categorical(y_train, nb_classes)
#Y_test = np_utils.to_categorical(y_test, nb_classes)